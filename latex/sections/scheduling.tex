\subsection{Scheduling}\label{s:scheduling}
In der Fachliteratur wird der Begriff Scheduling mit zwar unterschiedlichen Begriffen, jedoch gleicher Bedeutung definiert. Michael Pinedo definiert Scheduling in seinem Werk \cite{mpinedo} folgendermaßen:
\begin{quote}
\textit{"`Scheduling is a decision-making process [...]. It deals with the allocation of resources to tasks over given time periods and its goal is to optimize one ore more objectives."'}
\end{quote}
So definiert er Scheduling als einen Entscheidungsprozess, der sich mit der zeitlichen Zuteilungen von Re"-ssourcen zu Aufgaben beschäftigt. Dabei ist das Ziel, ein oder mehrere Eigenschaften zu optimieren. Ferner erklärt er, dass die Ressourcen und Aufgaben in einer Organisation unterschiedliche Formen annehmen können. Ressourcen können beispielsweise Maschinen in einer Fertigungsanlage, Landebahnen auf einem Flughafen oder Verarbeitungseinheiten in einem Rechnersystem sein. Die Aufgaben wären analog Operationen in der Fertigunsanlage, Start und Landung auf dem Flughafen oder Programmausführungen im Computer. Eigenschaften der einzelnen Aufgaben sind zum Beispiel gewisse Prioritäten, frühester Startzeitpunkt oder ein Ablaufdatum. Die zu optimierende Ziele können ebenfalls viele verschiedene Formen annehmen. Das könnten die Reduzierung der gesamten Ausführungszeit einer Aufgabe sein oder die Minimierung der Anzahl von Aufgaben, die nach ihrer Fälligkeit abgeschlossen wurden.

Eine andere Definition ist von Alessandro Agnetis aus seinem Buch \cite{aagnetis}:
\begin{quote}
\textit{"`[...] by scheduling we mean all actions that have to be done in order to determine when each activity of a set is to start and to complete."'}
\end{quote}
So umfasst seiner Ansicht nach Scheduling diejenigen Tätig"-keiten, die zur Bestimmung der Start- und Endzeit einer Aktivität aus einem Set getätigt werden müssen. Den Begriff Job spezifiziert er als Aktivität aus einem Set. So ist jeder Job im Wettkampf mit den anderen um die Nutzung von Zeit und Ressourcen. Als Ressourcen charakterisiert der Autor alles, was zur erfolgreichen Ausführung der Jobs erforderlich ist. Wie M. Pinedo benennt er Scheduling ebenso als einen Prozess, der sich mit der Zuteilung von Ressourcen zu Jobs beschäftigt. Seiner Meinung nach ist ein \textit{Schedule} (Plan) somit durch eine Menge von Startzeiten und zugeteilten Ressourcen bestimmt, der einige vordefinierte Anforderungen erfüllt.\\
Zusammenfassend ergeben die Definitionen aus \cite{mpinedo} und \cite{aagnetis} einen Prozess, der die Planung und Zuteilungen von Ressourcen zu Aufgaben sowie deren Ausführung und Beobachtung beschreibt. Dazu kommt die Einbeziehung sowie Auflösung von Abhängig"-keiten zu anderen Systemen, die Start- und Endzeit einer jeden Aufgabe beeinflussen.

Der Scheduler verwaltet Ressourcen und Aufgaben und erstellt dazu einen optimalen Plan, der sicherstellen soll, dass alle Aufgaben mit ihren Eigenschaften (Startzeit, Ablaufdatum, Priorität) und den benötigten Ressourcen erfolgreich ausgeführt werden. Oftmals ist es nicht einfach, einen optimalen Plan für die gegebenen Anforderungen zu finden. Kriterien, welche durch den Scheduler optimiert werden sollen, sind unten in diesem Abschnitt vorgestellt.\\
\cite{mpinedo} und \cite{aagnetis} zeigen ein Beispiel, in dem die Rolle des Scheduling in einer realen Umgebung illustriert wird:
\begin{description}
\item[Gate-Zuweisung am Flughafen]
An einem Airline-Termi"-nal eines größeren Flughafens gibt es dutzende Gates und hunderte von Flugzeugen, die täglich starten und landen. Sowohl die Gates als auch die Flugzeuge sind nicht identisch. Manche Gates haben räumlich viel Platz, sodass hier auch größere Flugzeuge angekoppelt werden können. Andere sind so gelegen, dass es schwierig ist die Flugzeuge ohne Unterstützung anzukoppeln. Obwohl die Flugzeuge nach einem gewissen Plan ankommen und wieder abheben, gibt es doch zufällige Änderungen, die vom Wetter oder anderen nicht vorhersehbaren Ereignissen beeinflusst werden. Während ein Flugzeug an einem Gate steht, müssen die Passagiere die Maschine verlassen. Diese muss getankt, gereinigt und beladen werden und anschließend die Passagiere des nächsten Fluges einsteigen. Die Abflugzeit ist hier das Ablaufdatum, da bis zu diesem Zeitpunkt alle Aufgaben abgeschlossen sein müssen. Wenn jedoch absehbar ist, dass das Flugzeug nicht am Zielflughafen landen kann, wird es auch nicht abheben. Aus Vorschriftsgründen bleiben die Passagiere dann im Terminal anstatt im Flugzeug. Das Flugzeug würde für eine erweiterte Zeit am Gate stehen bleiben und blockiert es somit für andere.\\
Der Scheduler muss die Flugzeuge so den Gates zuweisen, dass dies physisch möglich ist. Dies impliziert, dass die Flugzeuge an die Gates passen und diese zur geplanten Ankunftszeit auch zur Verfügung stehen. Anforderungen wie die zeitliche Reduktion eines Arbeitsvorgangs für das Airline Personal oder die Reduzierung von Verspätungen müssen dabei optimiert werden.\\
In diesem Beispiel sind die Gates die Ressourcen und die Wartung der Flugzeuge die Aufgaben. 
\end{description}
Im Kontext des \textit{Prozess-Scheduling} definiert Avi Silberschatz in \cite{asilberschatz}, dass dieses dafür verantwortlich ist, dass die Prozesse aus den Warteschlangen ausgeführt werden können. Dazu erteilt der Scheduler den Prozessen eine gewisse Zeit lang die CPU, in der sie diese Ressource benutzen können. Dabei müssen sowohl im Bezug auf die Prozesse als auch im Bezug auf das Gesamtsystem folgende Ziele optimiert werden \cite{asilberschatz} \cite{rlove}.\\
\textbf{Effizienz} ist im Sinne der Kosten-Nutzen-Relation gleich Ertrag durch Aufwand und ist ein Maß für den Umgang mit knappen Ressourcen (CPU, Fertigungsmaschine, Flughafengate, etc.). Um untätige Zeiten zu vermeiden, sollten also eine CPU maximal ausgelastet sein. Ebenso ist es wichtig einen hohen \textbf{Durchsatz} zu erreichen. Für das Scheduling bedeutet dies, dass möglichst viele Aufgaben pro Zeiteinheit ausgeführt werden sollen. Der Durchsatz hängt de facto stark von der Komplexität der Jobs in Verbindung mit der Masse an Jobs ab. \textbf{Fairness} ist im Kontext des CFS ein sehr wichtiger Faktor (siehe auch \ref{s:fair}): Die Neutralität von Ressourcen sollte gewährleistet sein; jedem Prozess ist im Gesamten die gleiche Prozessorzeit zuzuteilen. Damit wird verhindert, dass eine Instanz \textit{verhungert}, somit nicht dauerhaft vernachlässigt wird. Mechanismen für Fairness sind beispielsweise \textit{Preemption} (Verdrängung) oder \textit{Round Robin} (Zeitscheibenverfahren). 
Aufgaben, die ein Ablaufdatum besitzen, müssen so eingeplant werden, dass der definierte Zeitpunkt eingehalten wird. Es existieren unterschiedliche Formen von \textbf{Deadlines} bzw. Echtzeitanforderungen: Bei einer \textit{harten} Deadline muss das Ablaufdatum präzise, bei \textit{weicher} Deadline einigermaßen eingehalten werden. Ferner sollte bei jedem Scheduling-Algorithmus versucht werden, die \textbf{Komplexität} so gering wie möglich zu halten (niedrige Aufwände im Bezug auf die O-Notation). Die Scheduling-Operatio"-nen sollten \textbf{einfach und schnell} verfahren sowie transparent sein.  

Für alle Scheduling-Systeme ist es wünschenswert, die Effizienz und den Durchsatz zu maximieren sowie  die Ab"-arbeitungs- und Antwortzeiten zu minimieren. In Batch-Systemen wird Wert auf einen hohen Durchsatz und geringe Antwortzeiten gelegt. In interaktiven (time-sharing) Systemen (bspsw. Betriebssystemen) ist es wichtiger, die Varianz der Antwortzeiten anstatt die durschnittliche Antwortzeit zu minimieren. Realzeitsysteme (z.B. Prozessleittechnik, Motorsteuerung, Robotik) hingegen legen einen hohen Wert auf die Einhaltung der Ablaufdaten und geringe Abarbeitungszeiten \cite{asilberschatz}.\\


%Prozesse können entweder als I/O-gebunden oder als Prozessorgebunden klassifiziert werden (nach \cite{rlove}): Erstere verbringen einen Großteil ihres Lebenszyklus damit, I/O-Ope\-rationen anzuweisen oder darauf zu warten. Bestes Beispiel hierfür sind graphische Userinterfaces wie Texteditoren. Umgekehrt führen prozessorgebundene Prozesse die meiste Zeit ihres Lebenszyklus Code aus und werden häufig durch den Scheduler verdrängt. Ein gutes Beispiel hierfür ist das Tool \textit{ssh-keygen} oder das Rendern eines Videos durch einen Codec.\\
%Viele Scheduler-Algorithmen arbeiten mit einer Kombination aus Prozessprioritäten und Zeitscheiben \cite{rlove}. Bei ersterem ist das Ziel, die Prozesse basierend auf ihrem Wert und dem Anspruch auf Prozessorzeit einzustufen. Prozesse mit höhere Priorität laufen vor Prozessen mit niedrigerer Priorität und bei Gleichheit wird per round-robin-Verfahren ausgewählt. Der Linux-Kernel implementiert da\-für u.a. den sogenannten \textit{nice}-Wert in einem Interval von -20 bis +19 und dem Standardwert 0. Höhere nice-Werte korrespondieren zu niedrigeren Prioritäten. Umgangssprachlich ist der Prozess  \textit{netter} zu anderen Prozessen. Prozesse mit niedrigerem nice-Wert erhalten einen größeren Anteil an der CPU. \\
%Über Zeitscheiben wird im Allgemeinen gesteuert, wie lange ein ausgewählter Prozess die CPU erhält bevor er vom Scheduler verdrängt wird \cite{rlove}. Dabei ist es wichtig, dass der Wert der Zeitscheiben nicht zu niedrig aber auch nicht zu hoch gewählt wird. Zu kurze Zeitscheiben führen zu einer geringen Effizienz, da beachtliche Zeit im Overhead für Prozesswechsel verloren geht. Zu lange Zeitscheiben führen dazu, dass das System im interaktiven Betrieb zu lange Antwortzeiten besitzt. Hier kommt auch wieder die Kontroverse zwischen I/O-gebundenen und prozessorgebundenen Prozessen zum Tragen, da erstere keine langen Zeitscheiben brauchen dafür aber oft ausgeführt werden wollen und zweitere nach langen Zeitscheiben verlangen, um z.B. die Caches aktuell zu halten.
%Wie der CFS-Scheduler diesen Spagat und die oben genannten Kriterien einhält wird ab Abschnitt \ref{s:cfsmain} erläu\-tert.
