\subsection{Parameter von Schedulern}
\textbf{Prozessarten}\\
In der Prozessverwaltung des Schedulers sollen insbesondere zwei Hauptprozessarten berücksichtigt werden. Zum einen gibt es I/O gebundene Prozesse. Diese Prozesse warten stehts auf Eingaben bzw. Ereignisse und führen danach entsprechenden Code aus. Daher kann man davon ausgehen, dass diese Prozesse immer nur relativ kurzläufig sind und danach in einer Art Ruhemodus auf weitere Instruktionen warten. Als Beispiel sei ein Graphical User Interface (GUI) zu nennen, welches hauptsächlich durch Interaktionen eines Benutzers zur Arbeit aufgefordert wird.

Die zweite Prozessart, welche vom Scheduler behandelt werden muss, ist die prozessorgebundene. Diese Prozesse sind hauptsächlich damit beschäftigt Algorithmen auszuführen und be\-nötigen daher viel Prozessorzeit. Ausserdem laufen diese Prozesse meist solange, bis sie unterbrochen werden.
Es gibt aber auch Mischformen aus beiden Arten. Ein gutes Beispiel ist das X-Window System unter Linux. Dies soll eine grafische Interaktivitätsumgebung für den Benutzer bereitstellen und muss aber gleichzeitig im Hintergrund einige Berechnungen durchführen, um zum Beispiel eine gewisse Anwenderfreundlichkeit gewähr\-leis\-ten zu können. 
Auch das Wörterbuch des bekannten Betriebssystems \textit{Android} stellt eine Mischform beider Prozessarten da. Schon während der Benutzer die einzelnen Buchstaben eingibt, berechnet der passende Prozess im Hintergrund eine Vorschau mit Wörtern, um eine Auto\-ver\-voll\-ständigung des Wortes zu erstellen.
Für den Scheduler entstehen in diesem Bereich damit auch zwei wichtige Anforderungen. Zum einem soll er eine schnelle Antwortzeit auf Interaktionen eines Users ermöglichen und zum andern einen hohen Durchsatz für prozessorgebundene Prozesse bereitstellen.

\textbf{Prioritäten}\\
Damit ein Scheduler eine Auswahl auf die zu aktivierenden Prozesse treffen kann, müssen diese mit Hilfe einer Bewertung attribuiert werden. Diese Möglichkeit wird unter Linux und unixartigen Systemen unter anderem mit der Vergabe von Prioritäten hergestellt.
Dabei sollen höher priorisierte Prozesse schneller eine Zuteilung bekommen als niedriger priorisierte Prozesse. Gleichwertige werden mit Hilfe eines Round-Robin Verfahrens bzw. durch eine Warteschlange ausgewählt. In manchen Systemen wird sogar die Länge, d.h. wie lange ein Prozess die Zuteilung behalten darf, über die Prioritätsattribute verwaltet. Um während des laufenden Systems auch Anpassungen vornehmen zu kön\-nen, ist es den Benutzern sowie dem System gestattet diese Prioritäten während der Laufzeit zu ändern.
In Linux sind zwei Prioritäts\-reihen aktiv. Die erste Reihe hat einen Bereich von -20 bis +19. Diese werden als \textit{nice}-Werte bezeichnet. Der Standard liegt hier in der Mitte bei 0. Ein niedriger Wert \textit{nice}-Wert bedeutet, dass der Prozess einen größeren Anteil der zur Verfügung stehenden Prozessorressource zugeteilt bekommt als ein Prozess mit einem höheren \textit{nice}-Wert.
Unter UNIX hat sich dieses Verfahren als Standard durchgesetzt, allerdings kann der \textit{nice}-Wert durch verschiedene Scheduler-Algorithmen auch unterschiedlich verwendet werden.

Die zweite Reihe von Prioritäten in Linux Systemen ist die Real-Time-Reihe. Diese hat einen Bereich von 0 bis 99 und wird allgemein den \textit{nice}-Werten bevorzugt. In diesem Umfeld spielt die Höhe des Wertes allerdings eine genau gegensätzliche Rolle wie bei den \textit{nice}-Werten. Je höher der Wert in der Real-Time-Reihe, desto höher die Priorität. Unter UNIX wurde mit POSIX.1b ein Standard für diese Anwendung der Realtime Prozesse erstellt, welcher im Linux-Betriebssystem eine hundertprozentig Anpassung gefunden hat \cite{rlove}.

\textbf{Zeitscheiben}\\
Damit mehrere Prozesse scheinbar nebeneinander laufen können bzw. auch überhaupt eine Interaktionmöglichkeit für Benutzer geschaffen werden kann, ist es nötig Prozesse zu unterbrechen und einem anderen wartenden Prozess einen Zugriff auf die Prozessor\-ressource zu gewähren. Mit Hilfe von Zeitscheiben können Fenster erstellt werden, in denen ein Prozess für eine bestimmte Zeit eine Zuteilung erhält und danach unterbrochen wird.
Aufgabe des Schedulers ist es an dieser Stelle mit Hilfe entsprechender Regeln solche Zeitscheiben für die jeweiligen Prozesse zu errechnen. Dabei gibt es folgende Punkte zu beachten:

Werden die Zeitscheiben zu groß bzw. zu lang gewählt, dann leidet die Interaktionsmöglichkeit für den Benutzer und außerdem kann dann der Anschein der Parallel\-ver\-arbeitung nicht mehr geweckt werden.
Werden sie zu klein gewählt, dann ist der Prozessor nur noch mit den Umschaltvorgängen beschäftigt und die allgemeine Systemperformance wird erheblich gesenkt.

Auch der oben bereits erwähnte Unterschied zwischen I/O und prozessorgebunden Prozessen spielt eine wesentlich Rolle bei der Festlegung der Zeitscheiben. I/O Prozesse benötigen meist nur eine geringe Zeitscheibe, wohingegen die prozessorgebundenen eine größere Zeitscheibe bekommen sollten. 
Als Standardwert hat sich an dieser Stelle bei vielen Betriebssystemen ein Wert \textless10ms etabliert \cite{rlove}, da damit unter anderem eine gute Inter\-ak\-ti\-vitäts\-mög\-lich\-keit bewahrt wird.
%
%Der CF-Scheduler verteilt oder berechnet keine direkten Zeitscheiben an die Prozesse. Bei diesem Verfahren wird ein Anteil der CPU berechnet. Die Menge an Zeit, welche ein Prozess zugeteilt bekommt, ergibt sich aus einer Funktion, welche die Gesamtbelastung eines System integriert.
%Dieser Anteil wird direkt beeinflusst durch das Gewicht jedes Prozesses, welches durch den \textit{nice}-Wert ermittelt wird. Hoher Nice-Wert bedeutet weiterhin, dass der Anteil des Prozessor für diesen Prozess vermindert wird. Ein niedriger \textit{nice}-Wert sorgt für eine Erweiterung des Anteil für die CPU.
%Wenn ein Prozess zu bereit überwechselt, muss der Scheduler entscheiden, ob er einen laufenden Prozess unterbrechen darf oder ob er warten muss. Viele Scheduler berechnen diese Erlaubnis aus einer Funktion von Prioritäten und Zeitschlitzen. Der CF-Scheduler hingegen gewinnt diese Entscheidung aus dem aktuellen Verbrauch dieses Prozesses. D.h. wieviel Zuteilung hat der neue Prozess bereits erhalten im Vergleich zum aktuell laufenden Prozess. Wenn dieser Wert kleiner ist, dann wird der laufende Prozess gestoppt und der neue Prozess erhält direkt die Zuteilung.