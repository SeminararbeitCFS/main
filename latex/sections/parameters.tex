\subsection{Parameter der Linux Scheduler}
\subsubsection{Prozessarten}
In der Prozessverwaltung des Schedulers sollen insbesondere zwei Hauptprozessarten berücksichtigt werden. Zum einen gibt es I/O gebundene Prozesse. Diese Prozesse warten stehts auf Eingaben bzw. Ereignisse und führen danach entsprechend Code aus. Daher kann man davon ausgehen, dass die Prozesse immer nur relative kurzläufig sind und sich danach im Wartemodus befinden. Als Beispiel sei z.B. eine GUI zu nennen, welche nur durch Interaktionen eines Users arbeiten kann.
Die zweite Prozessart, welche vom Scheduler behandelt werden muss, sind die Prozessor gebundenen Prozesse. Diese Prozesse sind hauptsächlich damit beschäftigt, Algorithmen auszuführen und daher be\-nötigen sie sehr viel Prozessorzeit. Ausserdem laufen diese Prozesse meist solange, bis sie unterbrochen werden.
Es gibt aber auch Mischformen aus beiden Arten. Ein gutes Beispiel ist zum Beispiel das X-Windows System unter Linux. Diese soll eine grafische Interaktivitätsumgebung für den Benutzer bereitstellen und muss aber auch gleichzeitig im Hintergrund einige Berechnung durchführen um dieses zu ermöglichen. 
Auch das Wörterbuch des bekannten Android Betriebssystem stellt eine Mischform beider Prozessarten da. Schon während der Benutzer die einzelnen Buchstaben eingibt, berechnet der passende Prozess im Hintergrund eine Vorschau mit Wörtern um eine Autovervollständigung zu ewrmöglichen.
Für den Scheduler entstehen in diesem Bereich damit auch zwei wichtige Anforderungen. Zum einem soll er eine schnelle Antwortzeit auf Interaktionen eines Users ermöglichen. Zum andern einen hohen Durchsatz für Prozessorgebundene Prozesse bereitstellen.

\subsubsection{Prioritäten}
Damit ein Scheduler eine Auswahl auf die zu aktivierenden Prozess treffen kann, müssen diese mit Hilfe einer Bewertung attribuiert werden. Diese Möglichkeit wird unter Linux und Unix-artigen Systemen mit Hilfe von Prioritäten erzeugt.
Dabei sollen höher priorisierte Prozesse schneller eine Zuteilung bekommen, als die niedrigeren. Gleichwertige werden mit Hilfe eines Round-Robin Verfahrens bzw. mit einer Wartschlange ausgewählt. In manchen Systemen wird sogar die Länge, d.h. wie lange ein Prozess die Zuteilung behalten darf, über die Prioritäts-Attribute verwaltet. Um während des laufenden Systems auch Anpassungen vornehmen zu können, ist es den Usern sowie dem System gestattet, diese Prioritäten währen der Laufzeit zu ändern.
In Linux sind sogar zwei Prioritäts\-reihen aktiv. Die erste Reihe hat einen Bereich von -20 bis +19 und diese werden als NICE-Werte bezeichnet. Der Standard liegt hier in der Mitte bei 0. Ein niedriger Wert NICE-Wert bedeutet, dass der Prozess einen größeren Anteil der zur Verfügung stehenden Prozessorressource zugeteilt bekommt als ein Prozess mit einem höheren NICE-Wert.
Unter UNIX hat sich dieses Verfahren als Standard durchgesetzt, allerdings kann der NICE-Wert durch verschiedene Scheduler-Algorithmen auch unterschiedlich verwendet werden.

Die zweite Reihe von Prioritäten, welche in Linux Systemen implementiert ist, sind die Prioritäten der Real-Time Reihe. Diese haben einen Bereich von 0 bis 99 und werden allgemein den NICE-Werten bevorzugt. In diesem Umfeld spielt die Höhe des Wertes allerdings eine genau gegensätzliche Rolle,  wie bei den NICE-Werten. Je höher der Wert, desto höher die Priorität. Unter UNIX wurde mit POSIX.1b ein Standard für diese Anwendung der Realtime Prozesse erstellt, welchen sich das Linux-System hundertprozentig angeschlossen hat.

\subsubsection{Zeitscheiben}
Damit mehrere Prozesse scheinbar nebeneinander laufen können bzw. auch überhaupt interaktion mit gleichzeitigen Berechnung zu ermöglichen, ist es nötig Prozesse zu unterbrechen und einem weiteren Wartenden Prozess eine Zuteilung auf die Prozessorressource zu ermöglichen. Mit Hilfe eines Zeitscheiben können nun Fenster erstellt werden, in dem ein Prozess für eine bestimmte Zeit eine Zuteilung erhält und danach unterbrochen wird.
Aufgabe des Schedulers ist es an dieser Stelle mit Hilfe entsprechender Regeln, solche Zeitscheiben  für die jeweiligen Prozesse zu errechnen. Dabei gibt es folgende Punkte zu beachten:
Werden die Zeitschlitze so groß bzw. zu lang gewählt, dann leidet die Interaktionsmöglichkeit für den Benutzer darunter und außerdem kann dann der Anschein der Parallel-Verarbeitung nicht mehr geweckt werden.
Werden sie zu klein gewählt, dann ist der Prozessor nur noch mit den Umschaltvorgänge beschäftigt und die allgemeine Systemperformance wird erheblich gesenkt.

Auch der oben bereits erwähnt Unterschied zwischen I/O und Prozessor gebunden Prozessen spielt eine wesentlich Rolle bei der Festlegung der Zeitscheiben. I/O benötigen meist nur eine geringe Zeitscheibe, wohingegen die Prozessorgebundenen eine größere Zeitscheibe bekommen sollten. Als Standardwert hat sich eine dieser Stelle ein Wert von kleiner als 10ms etabliert. Damit wird eine gute Interaktivitätsmöglichkeit bewahrt.

Der CF-Scheduler verteilt oder berechnet keine direkten Zeitscheiben an die Prozesse. Bei diesem Verfahren wird ein Anteil der CPU berechnet. Die Menge an Zeit, welche ein Prozess zugeteilt bekommt, ergibt sich aus einer Funktion, welche die Gesamtbelastung eines System integriert.
Dieser Anteil wird direkt beeinflusst durch das Gewicht jedes Prozesses, welches durch den NICE-Wert ermittelt wird. Hoher Nice-Wert bedeutet weiterhin, dass der Anteil des Prozessor für diesen Prozess vermindert wird. Ein niedriger NICE-Wert sorgt für eine Erweiterung des Anteil für die CPU.
Wenn ein Prozess zu bereit überwechselt, muss der Scheduler entscheiden, ob er einen laufenden Prozess unterbrechen darf oder ob er warten muss. Viele Scheduler berechnen diese Erlaubnis aus einer Funktion von Prioritäten und Zeitschlitzen. Der CF-Scheduler hingegen gewinnt diese Entscheidung aus dem aktuellen Verbrauch dieses Prozesses. D.h. wieviel Zuteilung hat der neue Prozess bereits erhalten im Vergleich zum aktuell laufenden Prozess. Wenn dieser Wert kleiner ist, dann wird der laufende Prozess gestoppt und der neue Prozess erhält direkt die Zuteilung.