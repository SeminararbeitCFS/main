\subsection{Parameter von Schedulern}
\textbf{Prozessarten}\\
In der Prozessverwaltung des Schedulers sollen insbesondere zwei Hauptprozessarten berücksichtigt werden. Zum einen gibt es I/O gebundene Prozesse. Diese Prozesse warten stehts auf Eingaben bzw. Ereignisse und führen danach entsprechend Code aus. Daher kann man davon ausgehen, dass diese Prozesse immer nur relativ kurzläufig sind und danach in einer Art Ruhemodus auf weitere Instruktionen warten. Als Beispiel sei z.B. eine GUI zu nennen, welche hauptsächlich nur durch Interaktionen eines Benutzers zur Arbeit aufgefordert wird.

Die zweite Prozessart, welche vom Scheduler behandelt werden muss, ist die prozessorgebundene. Die prozessorgebundenen Prozesse sind hauptsächlich damit beschäftigt, Algorithmen auszuführen und be\-nötigen daher viel Prozessorzeit. Ausserdem laufen diese Prozesse meist solange, bis sie unterbrochen werden.
Es gibt aber auch Mischformen aus beiden Arten. Ein gutes Beispiel ist zum Beispiel das X-Windows System unter Linux. Diese soll eine grafische Interaktivitätsumgebung für den Benutzer bereitstellen und muss aber auch gleichzeitig im Hintergrund einige Berechnung bzw. Dienste dauert ausführen, um zum Beispiel eine gewisse Anwenderfreundlichkeit gewähr\-leis\-ten zu können. 
Auch das Wörterbuch des bekannten Android Betriebssystem stellt eine Mischform beider Prozessarten da. Schon während der Benutzer die einzelnen Buchstaben eingibt, berechnet der passende Prozess im Hintergrund eine Vorschau mit Wörtern um eine Auto\-ver\-voll\-ständigung des Wortes zu erstellen.
Für den Scheduler entstehen in diesem Bereich damit auch zwei wichtige Anforderungen. Zum einem soll er eine schnelle Antwortzeit auf Interaktionen eines Users ermöglichen. Zum andern einen hohen Durchsatz für prozessorgebundene Prozesse bereitstellen.

\textbf{Prioritäten}\\
Damit ein Scheduler eine Auswahl auf die zu aktivierenden Prozesse treffen kann, müssen diese mit Hilfe einer Bewertung attribuiert werden. Diese Möglichkeit wird unter Linux und Unix-artigen Systemen unter anderem mit Zuhilfenahme von Prioritäten erstellt.
Dabei sollen höher priorisierte Prozesse schneller eine Zuteilung bekommen, als die niedrigeren. Gleichwertige werden mit Hilfe eines Round-Robin Verfahrens bzw. mit einer Wartschlange ausgewählt. In manchen Systemen wird sogar die Länge, d.h. wie lange ein Prozess die Zuteilung behalten darf, über die Prioritäts-Attribute verwaltet. Um während des laufenden Systems auch Anpassungen vornehmen zu kön\-nen, ist es den Benutzern sowie dem System gestattet, diese Prioritäten währen der Laufzeit zu ändern.
In Linux sind sogar zwei Prioritäts\-reihen aktiv. Die erste Reihe hat einen Bereich von -20 bis +19 und diese werden als \textit{nice}-Werte bezeichnet. Der Standard liegt hier in der Mitte bei 0. Ein niedriger Wert \textit{nice}-Wert bedeutet, dass der Prozess einen größeren Anteil der zur Verfügung stehenden Prozessorressource zugeteilt bekommt als ein Prozess mit einem höheren \textit{nice}-Wert.
Unter UNIX hat sich dieses Verfahren als Standard durchgesetzt, allerdings kann der \textit{nice}--Wert durch verschiedene Scheduler-Algorithmen auch unterschiedlich verwendet werden.

Die zweite Reihe von Prioritäten, welche in Linux Systemen implementiert ist, sind die Prioritäten der Real-Time-Reihe. Diese haben einen Bereich von 0 bis 99 und werden allgemein den \textit{nice}-Werten bevorzugt. In diesem Umfeld spielt die Höhe des Wertes allerdings eine genau gegensätzliche Rolle,  wie bei den \textit{nice}-Werten. Je höher der Wert in der Real-Time-Reihe, desto höher die Priorität. Unter UNIX wurde mit POSIX.1b ein Standard für diese Anwendung der Realtime Prozesse erstellt, welchen im Linux-Betriebssystem eine hundertprozentig Anpassung gefunden hat \cite{rlove}.

\textbf{Zeitscheiben}\\
Damit mehrere Prozesse scheinbar nebeneinander laufen können bzw. auch überhaupt eine Interaktionmöglichkeit für Benutzer geschaffen werden kann, ist es nötig Prozesse zu unterbrechen und einem anderen wartenden Prozess eine Zuteilung auf die Prozessor\-ressource zu gewähren. Mit Hilfe von Zeitscheiben können Fenster erstellt werden, in denen ein Prozess für eine bestimmte Zeit eine Zuteilung erhält und danach unterbrochen wird.
Aufgabe des Schedulers ist es an dieser Stelle mit Hilfe entsprechender Regeln, solche Zeitscheiben  für die jeweiligen Prozesse zu errechnen. Dabei gibt es folgende Punkte zu beachten:

Werden die Zeitscheiben zu groß bzw. zu lang gewählt, dann leidet die Interaktionsmöglichkeit für den Benutzer und außerdem kann dann der Anschein der Parallel\--Ver\-arbeitung nicht mehr geweckt werden.
Werden sie zu klein gewählt, dann ist der Prozessor nur noch mit den Umschaltvorgänge beschäftigt und die allgemeine Systemperformance wird erheblich gesenkt.

Auch der oben bereits erwähnt Unterschied zwischen I/O und prozessorgebunden Prozessen spielt eine wesentlich Rolle bei der Festlegung der Zeitscheiben. I/O Prozesse benötigen meist nur eine geringe Zeitscheibe, wohingegen die prozessorgebundenen eine größere Zeitscheibe bekommen sollten. Als Standardwert hat sich eine dieser Stelle ein Wert von kleiner als 10ms etabliert. Damit wird eine gute Interaktivitätsmöglichkeit bewahrt.
%
%Der CF-Scheduler verteilt oder berechnet keine direkten Zeitscheiben an die Prozesse. Bei diesem Verfahren wird ein Anteil der CPU berechnet. Die Menge an Zeit, welche ein Prozess zugeteilt bekommt, ergibt sich aus einer Funktion, welche die Gesamtbelastung eines System integriert.
%Dieser Anteil wird direkt beeinflusst durch das Gewicht jedes Prozesses, welches durch den \textit{nice}-Wert ermittelt wird. Hoher Nice-Wert bedeutet weiterhin, dass der Anteil des Prozessor für diesen Prozess vermindert wird. Ein niedriger \textit{nice}-Wert sorgt für eine Erweiterung des Anteil für die CPU.
%Wenn ein Prozess zu bereit überwechselt, muss der Scheduler entscheiden, ob er einen laufenden Prozess unterbrechen darf oder ob er warten muss. Viele Scheduler berechnen diese Erlaubnis aus einer Funktion von Prioritäten und Zeitschlitzen. Der CF-Scheduler hingegen gewinnt diese Entscheidung aus dem aktuellen Verbrauch dieses Prozesses. D.h. wieviel Zuteilung hat der neue Prozess bereits erhalten im Vergleich zum aktuell laufenden Prozess. Wenn dieser Wert kleiner ist, dann wird der laufende Prozess gestoppt und der neue Prozess erhält direkt die Zuteilung.