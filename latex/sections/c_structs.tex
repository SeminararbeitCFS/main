\subsection{Implementierung im Linux-Kernel}\label{s:cstructs}
Im folgenden Abschnitt werden Datenstrukturen und Funktionen der Programmiersprache C aus dem Linux-Kernel vorgestellt, die für Scheduling - Aktivitäten des CFS genutzt werden. Dies umfasst die gewichtete Berechnung der genutzten Prozessorzeit sowie den nötigen Aktionen zur Prozessselektion (Einfügen, Lö"-schen und Auswahl eines Prozesses). Die Erläuterungen folgen den Diskussionen aus \cite{rlove}. Aus Gründen der Über"-sicht"-lichkeit wird hier auf die Darstellung von Sourcecode verzichtet. Diese können zum Beispiel im Internet unter \url{https://github.com/torvalds/linux/tree/master/kernel/sched} eingesehen werden.

Wie in Kapitel \ref{s:cfs_fktweise} erläutert, ordnet der CFS jedem Prozess die gewichtete Prozessorzeit \textit{virtual runtime} zu. \\
In der ersten Version im Kernel 2.6.23 wurde die \textit{virtual runtime} aus der Kombination einer systemweiten \texttt{fair\_ clock} Variable und der Wartezeit eines jeden Prozesses \texttt{wait\_runtime} akkumuliert. Die \textit{fair clock} tickt genau so in Echtzeit, sodass diese im idealen Tempo einer einzelnen Aufgabe läuft, falls N Aufgaben im System sind. Die \textit{wait\_runtime} ist die Zeit einer jeden Aufgabe, in der der Prozessor einer anderen zugeordnet war \cite{cpabla}.\\
Seit Kernel 2.6.24 ist die \textit{virtual runtime} in der Datenstruktur \texttt{sched\_entity} (eingebettet in der \texttt{struct} für Prozessdeskriptor \texttt{task\_struct}) als Variable \texttt{vruntime} deklariert. Diese ist in Nanosekunden angeben und somit losgelöst von der Frequenz des System - Timers \cite{rlove}. CFS nutzt genau diesen Wert um das \textit{completely fair} Prinzip anzuwenden, also um zu messen wie lange ein Prozess gelaufen ist und somit wie viel länger er laufen sollte.
Der Wert für die \textit{virtual runtime} ist gleichzeitig der Schlüssel im gewichteten Rot-Schwarz-Baum, der alle lauffähigen Prozesse beinhaltet. Daher beinhaltet \texttt{sched\_entity} auch eine Referenz auf den Rot-Schwarz-Baum in dem sich der lauffähige Prozess befindet. Diese Referenz kann natürlich auch leer sein, da nur Prozesse im Rot-Schwarz-Baum angeordnet sind, die sich auch in einem zur Ausführung bereiten Zustand befinden.

Die Funktion welche genutzt wird, um die  \texttt{virtual \- runtime} stets aktuell zu halten ist \texttt{update\_curr()} aus \texttt{kernel/sched\_fair.c}. Hier wird die Formel \ref{eq:vruntime} aus Kapitel \ref{s:cfs_fktweise} implementiert. Diese berechnet die Aus"-führungszeit des aktuellen Prozesses und speichert den Wert in der Variablen \texttt{delta\_exec}, welche wiederum an die unten aufgeführte Unterfunktion \texttt{\_\_update\_curr()} über"-geben wird. Diese ist dafür zuständig den Wert von \texttt{delta\-\_exec} mit der Anzahl an laufenden Prozessen zu gewichten. Die \texttt{vruntime} des aktuellen Prozesses wird um diesen Wert inkrementiert.  Ein immer präziser Wert für die \textit{virtual runtime} wird erreicht, weil diese Funktion sowohl periodisch durch den Systemtimer als auch jedes Mal wenn ein Prozess blockiert, ausführbar oder nicht mehr lauffähig wird, aufgerufen wird. 

Anhand der Diskussion in Kapitel \ref{s:cfs_fktweise} über ideale, perfekte Multitasking - Prozessoren lässt sich herleiten, dass die \textit{virtual runtime} in diesem Szenario für jeden Prozess gleich wäre. In der Realität hingegen muss der CFS immer wieder einen neuen Prozess für die Ausführung aus dem Baum auswählen. Um die Fairness zu wahren, wählt er dafür immer den Prozess mit dem niedrigsten Wert für \texttt{vruntime}. Dieser Prozess ist im Rot-Schwarz-Baum der Knoten ganz links. In Kernel - Code ist dafür die Funktion \texttt{\_\_pick\_next\_entity} verantwortlich. Beim Analysieren der Implementierung fällt auf, dass der Rot-Schwarz-Baum nicht tatsächlich traversiert wird, da ein zwischengespeicherter Wert \texttt{rb\_leftmost} existiert. Auch wenn es mit einem Aufwand von O(log n) (bei n Knoten) effizient wäre den Baum zu durchsuchen, ist es noch einfacher und schneller einen zwischengespeicherten Wert direkt zu adressieren. Wenn der Rot-Schwarz-Baum nicht leer ist und somit lauffähige Prozesse vorhanden sind, gibt die Funktion den Prozess zurück, den CFS als nächstes ausführen wird. Die Inhalte des Baumes migrieren also von rechts nach links um die Fairness zu gewährleisten. Nach \cite{mjones} verfolgt jeder lauffähige Prozess die anderen, um die faire Ausführung über alle lauffähigen Aufgaben im Gleichgewicht zu halten.

Wenn ein Prozess seinen Zustand in Ausführbar ändert (oder erstmalig durch \texttt{fork()} erstellt wird) muss dieser durch den CFS dem Rot-Schwarz-Baum hinzugefügt werden. Im gleichen Schritt wird auch der Knoten ``ganz links'' (kleinste \texttt{vruntime}) zwischengespeichert. Dies geschieht analog wie beim Aktualisieren der \textit{virtual runtime} in einer Unterfunktion von \texttt{enqueue\_entitiy()}. In einer Schleife wird solange der neue Prozess mit bestehenden Knoten im Baum verglichen bis die korrekte Position des neuen Elements im Baum gefunden worden ist. Das Aktualisieren der Variabel \texttt{rb\_leftmost} ist dabei sehr trivial. Am Anfang der Schleife steht der Wert dafür auf eins. Sobald jedoch das neue Element im Baum nach rechts eingeordnet worden ist, kann es de facto nicht mehr das linkeste Element sein und die Variable wird genullt. Umgekehrt bleibt die Variable auf eins, falls das neue Element ausschließlich nach links eingeordnet worden ist. 
In beiden Fällen wird abschließend der neue Prozess im Baum eingehängt und darauf darauf folgend die Eigenschaften entgegen eines Ungleichgewichtes aktualisiert.

Analog dem Einfügen eines neuen Prozesses in den Baum, gibt es Ereignisse die ein Löschen eines Prozesses aus dem Baum erfordern. Dies geschieht üblicherweise wenn ein Prozess blockiert oder terminiert. Auch hier wird eine Unterfunktion aufgerufen, welche die eigentliche Aktion durchführt.
Da beim Löschen sechs verschiedene Konstellationen auftreten können, wie der für die erforderlichen Eigenschaften repariert werden kann \cite{tcormen}, bietet die C - Bibliothek für Rot-Schwarz-Bäume eine Funktion \texttt{rb\_erase()} für diese Anforderung bereits an. Wichtig für die Implementierung des CFS ist, dass der Zwischenspeicher für den linkesten Knoten aktualisiert wird. Falls dies genau der Prozess ist, der entfernt werden soll, muss natürlich mit einem Aufruf von \texttt{rb\_next()} der nächste Prozess zur Ausführung ausgewählt werden. 

Jedoch fällt hier auf, dass die Unterfunktion sehr simpel aufgebaut ist, da die Bibliothek der Rot-Schwarz-Baum Implementierung in C bereits eine Funktion \texttt{rb\_erase()} mitbringt, welche die nötigen Operationen durchführt. Wichtig ist aber auch beim Entfernen eines Prozesses, dass der Zwischenspeicher für den linkesten Knoten aktualisiert wird. Falls dies genau der Prozess ist, der entfernt werden soll, muss mit einem Aufruf von \texttt{rb\_next()} der nächste Prozess zur Ausführung ausgewählt werden. Diese beinhaltet ein traversieren zum jetzt neuen linkesten Knoten.

Die Erweiterung \textit{group scheduling} ist mit Kernel - Version 2.6.24 eingeführt worden. Vor dieser Erweiterung hat CFS versucht zu \underline{allen} Aufgaben im System fair zu sein. Beispielsweise bei 25 Prozessen im System, teilt CFS jedem Prozess 4\% CPU zu. Wenn nun aber 20 dieser Prozesse Benutzer A gehören und nur fünf Benutzer B, ist letzterer im Nachteil, da Nutzer A wesentlich mehr CPU bekommt als B. Das \textit{group scheduling} versucht dieses Problem zu lösen, indem CFS im Beispiel oben jeweils 50\% jedem Benutzer zuteilt und anschließend diesen Anteil fair über die jeweilige Anzahl an Prozessen verteilt \cite{cpabla}. 
