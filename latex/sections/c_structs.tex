\subsection{Implementierung im Linux-Kernel}\label{s:cstructs}
Im folgenden Abschnitt werden Datenstrukturen und Funktionen der Programmiersprache C aus dem Linux-Kernel vorgestellt, die für Scheduling-Aktivitäten des CFS genutzt werden. Dies umfasst die gewichtete Berechnung der genutzten Prozessorzeit sowie den nötigen Aktionen zur Prozessselektion (Einfügen, Lö"-schen und Auswahl eines Prozesses). Die Erläuterungen folgen den Diskussionen aus \cite{rlove}. Aus Gründen der Über"-sicht"-lichkeit wird hier auf die Darstellung von Sourcecode verzichtet. Diese können z.B. im Internet unter \footnote{\url{https://github.com/torvalds/linux/tree/master/kernel/sched}} eingesehen werden.

Wie in Kapitel \ref{s:cfs_fktweise} erläutert, ordnet der CFS jedem Prozess die gewichtete, bereits genutzte Prozessorzeit \textit{virtual runtime} zu. \\
In der ersten Version im Kernel 2.6.23 wurde die \textit{virtual runtime} aus der Kombination einer systemweiten \texttt{fair\_\\clock} Variable und der Wartezeit eines jeden Prozesses \texttt{wait\_runtime} akkumuliert. Der Timer, der \textit{fair clock} füllt, tickt genau in Echtzeit, sodass diese im idealen Tempo einer einzelnen Aufgabe läuft, falls \textit{N} Aufgaben im System sind. Die \textit{wait\_runtime} ist die Zeit einer jeden Aufgabe, in der der Prozessor einer anderen Aufgabe zugeordnet war \cite{cpabla}. Sie entspricht dem Gegenteil von \textit{virtual runtime}.\\
Seit Kernel 2.6.24 ist die \textit{virtual runtime} in der Datenstruktur \texttt{sched\_entity} (eingebettet in der \texttt{struct} für einen Prozessdeskriptor) als Variable \texttt{vrun\-time} deklariert. Diese ist in Nanosekunden angeben und somit losgelöst von der Frequenz des System-Timers \cite{rlove}. CFS nutzt genau diesen Wert, um das \textit{completely-fair} Prinzip anzuwenden, also um zu messen wie lange ein Prozess gelaufen ist und somit wie viel länger er laufen sollte.
Der Wert für die \textit{virtual runtime} ist gleichzeitig der Schlüssel im gewichteten Rot-Schwarz-Baum, der alle lauffähigen Prozesse beinhaltet. Daher beinhaltet \texttt{sched\_entity} auch eine Referenz auf den Rot-Schwarz-Baum, in dem sich der lauffähige Prozess befindet. Diese Referenz kann natürlich auch leer sein, da nur Prozesse im Rot-Schwarz-Baum angeordnet sind, die sich auch in einem zur Ausführung bereiten Zustand befinden.

Die Funktion, welche genutzt wird, um die  \texttt{virtual \- runtime} stets aktuell zu halten ist \texttt{update\_curr()} aus \texttt{kernel/sched\_fair.c}. Hier wird die Formel (\ref{eq:vruntime}) aus Kapitel \ref{s:cfs_fktweise} implementiert. Diese berechnet die Aus"-führungszeit des aktuellen Prozesses und speichert den Wert in der Variablen \texttt{delta\_exec} ($runtime(\tau_{i},t)$ in Formel (\ref{eq:vruntime})), welche wiederum an eine Unterfunktion über\-geben wird. Diese ist dafür zuständig den Wert \texttt{vruntime} des aktuellen Prozesses zu inkrementieren.  Ein immer präziser Wert für die \textit{virtual runtime} wird erreicht, weil diese Funktion sowohl periodisch durch den Systemtimer als auch jedes Mal augerufen wird, wenn ein Prozess blockiert, aus\-führbar oder nicht mehr lauffähig wird. 

Anhand der Diskussion in Kapitel \ref{s:cfs_fktweise} lässt sich herleiten, dass die \textit{virtual runtime} in diesem Szenario für jeden Prozess gleich wäre. In der Realität hingegen muss der CFS immer wieder einen neuen Prozess für die Ausführung aus dem Baum auswählen. Um die Fairness zu wahren, wählt er dafür immer den Prozess mit dem niedrigsten Wert für \texttt{vruntime}. Dieser Prozess ist im Rot-Schwarz-Baum der Knoten am weitesten links. Im Kernel-Code ist dafür die Funktion \texttt{\_\_pick\_next\_entity} verantwortlich. Beim \- Analysieren der Implementierung fällt auf, dass der Rot-Schwarz-Baum nicht tatsächlich traversiert wird, sondern durch den zwischengespeicherten Wert \texttt{rb\_leftmost} der nächste Prozess gewählt wird. Auch wenn es mit einem Aufwand von $O(log n)$ (bei $n$ Knoten) effizient wäre den Baum zu durchsuchen, ist es noch einfacher und schneller einen zwischengespeicherten Wert direkt zu adressieren. Wenn der Rot-Schwarz-Baum nicht leer ist und somit lauffähige Prozesse vorhanden sind, gibt die Funktion den Prozess zurück, den CFS als nächstes ausführen wird. Die Inhalte des Baumes migrieren in ihrem Lebenszyklus also von rechts nach links um die Fairness zu gewährleisten. Nach \cite{mjones} verfolgt jeder lauffähige Prozess die jeweils anderen, um die faire Ausführung über alle lauffähigen Aufgaben im Gleichgewicht zu halten.

Wenn ein Prozess seinen Zustand in ausführbar ändert (oder erstmalig durch \texttt{fork()} erstellt wird), muss dieser durch den CFS in den Rot-Schwarz-Baum eingefügt werden. Im gleichen Schritt wird auch der Knoten ``ganz links'' (kleinste \texttt{vruntime}) zwischengespeichert. Dies geschieht analog wie beim Aktualisieren der \textit{virtual runtime} in einer Unterfunktion von \texttt{enqueue\_entitiy()}. In einer Schleife wird so lange der neue Prozess mit bestehenden Knoten im Baum verglichen, bis die korrekte Position des neuen Elements im Baum gefunden worden ist. Das Aktualisieren der Variablen \texttt{rb\_leftmost} ist dabei sehr trivial. Am Anfang der Schleife steht der Wert dafür auf eins. Sobald jedoch das neue Element im Baum nach rechts eingeordnet worden ist, kann es de facto nicht mehr das linkeste Element sein und die Variable wird genullt. Umgekehrt bleibt die Variable auf eins, falls das neue Element ausschließlich nach links eingeordnet worden ist. 
In beiden Fällen wird abschließend der neue Prozess im Baum eingehängt und darauf folgend die Eigenschaften entgegen eines Ungleichgewichtes aktualisiert.

Analog dem Einfügen eines neuen Prozesses in den Baum, gibt es Ereignisse, die ein Löschen eines Prozesses aus diesem erfordern. Dies geschieht üblicherweise wenn ein Prozess blockiert oder terminiert. Auch hier wird eine Unterfunktion aufgerufen, welche die eigentliche Aktion implementiert.
Da beim Löschen sechs verschiedene Konstellationen auftreten können, wie der Rot-Schwarz-Baum für die erforderlichen Eigenschaften repariert werden kann \cite{tcormen}, bietet die C-Bibliothek für Rot-Schwarz-Bäume eine Funktion  \texttt{rb\_erase()} für diese Anforderung an. Wichtig für die Implementierung des CFS ist, dass der Zwischenspeicher für den linkesten Knoten aktualisiert wird. Falls dies genau der Prozess ist, der entfernt werden soll, muss natür\-lich mit einem Aufruf von \texttt{rb\-\_next()} der näch\-ste Prozess zur Ausführung ausgewählt werden. Dies beinhaltet dann auch ein Traversieren zum jetzt neuen linkesten Knoten.


Eine Erweiterung um die Fairness zu steigern, ist mit Ker\-nel-Version 2.6.24 eingeführt worden. Vor dem sogenannten \textit{group scheduling} hat CFS versucht zu \underline{allen} Aufgaben im System gleich fair zu sein. Beispielsweise bei 25 Prozessen im System, teilt CFS jedem Prozess 4\% CPU zu. Wenn nun aber 20 dieser Prozesse Benutzer A gehören und nur fünf Benutzer B, ist letzterer im Nachteil, da Nutzer A wesentlich mehr CPU bekommt als B. Das \textit{group scheduling} versucht dieses Problem zu lösen, indem CFS im Beispiel oben jeweils 50\% jedem Benutzer zuteilt und anschließend diesen Anteil fair über die jeweilige Anzahl an Prozessen verteilt \cite{cpabla}. 
