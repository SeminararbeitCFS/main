% !TEX encoding = UTF-8 Unicode

% Beispiel für ein LaTeX-Dokument im Format "seminarvorlage"
\documentclass[ngerman]{seminarvorlage}
% ngerman = Deutsch in neuer Rechtschreibung, alternativ english

\usepackage[utf8]{inputenc} % Kodierung der Umlaute
\usepackage{babel} % automatische Sprachanpassung, Sprache siehe oben
\usepackage{cleveref} % für bequeme Referenzen, siehe \cref unten
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{color}
\usepackage{listings}
\lstset{
  frame=trb,
  language=C,
  basicstyle=\small,
  breaklines=true, 
  numbers=left,              
  stepnumber=1,                     
  numberfirstline=false,
  tabsize=2,
  commentstyle=\color{magenta}, 
  keywordstyle=\color{blue},
  stringstyle=\color{red}
}


\begin{document}

% Unbedingt angeben: Titel, Autoren, E-Mail
% Freiwillig: Adresse
\title{The Completely Fair Scheduler}
\numberofauthors{2}
\author{
  \alignauthor Lukas Essig\\
    \email{lukas.essig@studium.fernuni-hagen.de}
  \alignauthor Peter Müller\\
    \email{peter.müller@studium.fernuni-hagen.de}
}

\maketitle

\abstract{ tbd. } % Trennhilfe \- manchmal nützlich

\keywords{Linux, CFS, Rot-Schwarz-Baum, Scheduling, completely fair}

% Section-Überschriften werden in GROSSBUCHSTABEN umgestellt
\section{Einleitung}
Ein Betriebssystem kann als eine Komposition von Computerprogrammen definiert werden, dass die Hardware eines Computers verwaltet und Anwendungsprogrammen zur Verfügung stellt. Die Software Betriebssystem fungiert als Vermittler zwischen dem Benutzer eines Computers und dessen Hardware. Der Prozessscheduler eines Betriebssystems ist für die Verteilung der CPU-Bandbreite gegenüber von Aufgaben (Prozessen) zuständig. Der Algorithmus des Schedulers bestimmt die Reihenfolge und wirkt auf die optimale Leistung ein.\\
Der Linux-Kernel ist einer der Bereiche, die aktiv durch die Open-Source-Community entwickelt und verbessert werden. Darunter fällt auch die Implementierung des Prozessschedulers. Der Completely Fair Scheduler (CFS) löste mit der Kernelversion 2.6.23 den seit Version 2.6 im Einsatz befindlichen O(1)-Scheduler ab.





\section{Grundlagen zum Scheduling}
In diesem Abschnitt wird der Begriff Scheduling im Allgemeinen und konkret im Bezug auf Prozess-Scheduling definiert und anhand von Beispielen exemplarisch konkretisiert. 
Darauf folgend werden die Kriterien wiederholt, die durch effizientes Scheduling optimiert werden.
Ebenso erfolgt eine Einführung in die Datenstruktur \textit{Rot-Schwarz-Baum} sowie dem \textit{completely fair} Prinzip.

\input{sections/scheduling}
\input{sections/parameters}
\input{sections/rb_tree}
\input{sections/cf_principe}


\section{Der Completely-Fair-Scheduler}\label{s:cfsmain}
Ziel dieses Abschnittes ist es, dem Leser ein grundlegendes Verständnis für die Funktionsweise des CFS zu vermitteln. Es wird konkretisiert, wie dieser Scheduler einen perfekten Multitasking-Prozessor approximiert und welche Datenstrukturen und Funktionen dafür in der Programmiersprache C im Linux-Kernel implementiert sind.

\input{sections/aufbau}
\input{sections/c_structs}
\input{sections/comp_to_O1}

\section{Zusammenfassung}
In dieser Arbeit sind die grundlegenden Eigenschaften und der Aufbau des CF-Schedulers dargestellt. Es wird gezeigt, dass der CF-Scheduler mit Hilfe bestimmter Algorithmen und Prinzipien versucht, immer eine faire Verteilung unter den aufzuführenden Prozessen zu erreichen. Außerdem wird dabei auch weiterhin eine annähernde Multi-Task Umgebung beibehalten. Ein Vergleich zum O(1) Scheduler bestätigt unter anderem im Bereich des Interaktiven X-Window Server eine deutliche Verbesserung der Latenzzeit.

Ein großes Problem stellt sich allerdings heraus, wenn der CF-Scheduler mit zu vielen Prozessen konfrontiert wird. Über\-steigt die Menge der Anfragen einen gewissen Rahmen, so wird sich der Scheduler mehr und mehr den Prinzipien des \glqq com\-pletely-fair\grqq{} Prinzips entfernen.  

Auch Programme, welche mit sehr vielen Threads arbeiten, zwingen den Scheduler zu einem Ungleichgewicht. Da der Scheduler taskbasiert arbeitet, erhalten Programme mit einer hohen Anzahl von Threads eine für sie vorteilhafte, aber für andere Programme unfaire Prozessorzuteilung. Ein Lösung für dieses Problem könnte der bereits in Entwicklung befindliche Process-Fair-Scheduler (PFS) bereitstellen. Dieser versucht eine faire Verteilung über die Prozesse selbst zu erreichen. Dabei wird z.B. das Gewicht des anstehenden Prozesses nochmal durch die Anzahl der Threads des sich gerade in Ausführung befindenen Programmes geteilt. Wie weit sich dieser Ansatz allerdings durchsetzen wird, muss in Zukunft durch praktischen Einsatz erprobt werden.

Es ist zu sehen, dass noch einige Anforderungen an den Scheduler bestehen bleiben.
Wie auch gerade im Bereich des Open-Source zu erwarten ist, steht dem Scheduler unter Linux-Systemen noch eine ständig Weiterentwicklung bevor.  

%Anhand dieser Erläuterung kann gesehen werden, dass der CF-Scheduler nur eine Annäherung an ein perfektes faires Scheduling erreicht. Das große Problem der CF-Scheduler ist eine übermäßige Menge an Prozessen. Wird diese Menge in einem gewissen Rahmen gehalten, so kann der CF-Scheduler das  completely-fair -Prinzip gut erreichen. 

% Eine neue Spalte anfangen mit
\pagebreak

% Bibliographie entweder direkt hier eingeben (nur im Notfall)...
%\begin{thebibliography}{9}
%\bibitem{acmcategories}
%How to classify works using ACM's computing classification system.
%\newblock \url{http://www.acm.org/class/how_to_use.html}.
%
%\bibitem{Ivory2001}
%M.~Y. Ivory and M.~A. Hearst.
%\newblock The state of the art in automating usability evaluation of user
%  interfaces.
%\newblock {\em ACM Comput. Surv.}, 33(4):470--516, 2001.
%
%\end{thebibliography}

% ... oder die Bibliographie mit Hilfe von BibTeX generieren,
% dies ist auf jeden Fall die bessere Lösung und sollte nach
% Möglichkeit immer verwendet werden:
\bibliographystyle{abbrv}
\bibliography{literatur} % Daten aus der Datei literatur.bib verwenden.

\end{document}
